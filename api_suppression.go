/*
SendPost API

Email API and SMTP relay to not just send and measure email sending, but also alert and optimise. We provide you with tools, expertise and support needed to reliably deliver emails to your customers inboxes on time, every time.

API version: 1.0.0
Contact: hello@sendpost.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sendpost

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SuppressionAPIService SuppressionAPI service
type SuppressionAPIService service

type ApiCountRequest struct {
	ctx context.Context
	ApiService *SuppressionAPIService
	xSubAccountApiKey *string
	from *string
	to *string
}

// Sub-Account API Key
func (r ApiCountRequest) XSubAccountApiKey(xSubAccountApiKey string) ApiCountRequest {
	r.xSubAccountApiKey = &xSubAccountApiKey
	return r
}

// from date
func (r ApiCountRequest) From(from string) ApiCountRequest {
	r.from = &from
	return r
}

// to date
func (r ApiCountRequest) To(to string) ApiCountRequest {
	r.to = &to
	return r
}

func (r ApiCountRequest) Execute() (*CountStat, *http.Response, error) {
	return r.ApiService.CountExecute(r)
}

/*
Count Method for Count

Count Total Suppressions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountRequest
*/
func (a *SuppressionAPIService) Count(ctx context.Context) ApiCountRequest {
	return ApiCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CountStat
func (a *SuppressionAPIService) CountExecute(r ApiCountRequest) (*CountStat, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CountStat
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SuppressionAPIService.Count")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subaccount/suppression/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xSubAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("xSubAccountApiKey is required and must be specified")
	}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-SubAccount-ApiKey", r.xSubAccountApiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSuppressionsRequest struct {
	ctx context.Context
	ApiService *SuppressionAPIService
	xSubAccountApiKey *string
	rSuppression *RSuppression
}

// Sub-Account API Key
func (r ApiCreateSuppressionsRequest) XSubAccountApiKey(xSubAccountApiKey string) ApiCreateSuppressionsRequest {
	r.xSubAccountApiKey = &xSubAccountApiKey
	return r
}

// Suppression content
func (r ApiCreateSuppressionsRequest) RSuppression(rSuppression RSuppression) ApiCreateSuppressionsRequest {
	r.rSuppression = &rSuppression
	return r
}

func (r ApiCreateSuppressionsRequest) Execute() ([]Suppression, *http.Response, error) {
	return r.ApiService.CreateSuppressionsExecute(r)
}

/*
CreateSuppressions Method for CreateSuppressions

Add Email Addresses To Suppression List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSuppressionsRequest
*/
func (a *SuppressionAPIService) CreateSuppressions(ctx context.Context) ApiCreateSuppressionsRequest {
	return ApiCreateSuppressionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Suppression
func (a *SuppressionAPIService) CreateSuppressionsExecute(r ApiCreateSuppressionsRequest) ([]Suppression, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Suppression
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SuppressionAPIService.CreateSuppressions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subaccount/suppression/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xSubAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("xSubAccountApiKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-SubAccount-ApiKey", r.xSubAccountApiKey, "")
	// body params
	localVarPostBody = r.rSuppression
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSuppressionRequest struct {
	ctx context.Context
	ApiService *SuppressionAPIService
	xSubAccountApiKey *string
	rDSuppression *RDSuppression
}

// Sub-Account API Key
func (r ApiDeleteSuppressionRequest) XSubAccountApiKey(xSubAccountApiKey string) ApiDeleteSuppressionRequest {
	r.xSubAccountApiKey = &xSubAccountApiKey
	return r
}

// Suppression content
func (r ApiDeleteSuppressionRequest) RDSuppression(rDSuppression RDSuppression) ApiDeleteSuppressionRequest {
	r.rDSuppression = &rDSuppression
	return r
}

func (r ApiDeleteSuppressionRequest) Execute() ([]DeleteResponse, *http.Response, error) {
	return r.ApiService.DeleteSuppressionExecute(r)
}

/*
DeleteSuppression Method for DeleteSuppression

Delete specific emails which are in suppression list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteSuppressionRequest
*/
func (a *SuppressionAPIService) DeleteSuppression(ctx context.Context) ApiDeleteSuppressionRequest {
	return ApiDeleteSuppressionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DeleteResponse
func (a *SuppressionAPIService) DeleteSuppressionExecute(r ApiDeleteSuppressionRequest) ([]DeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SuppressionAPIService.DeleteSuppression")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subaccount/suppression/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xSubAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("xSubAccountApiKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-SubAccount-ApiKey", r.xSubAccountApiKey, "")
	// body params
	localVarPostBody = r.rDSuppression
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSuppressionsRequest struct {
	ctx context.Context
	ApiService *SuppressionAPIService
	xSubAccountApiKey *string
	offset *int64
	limit *int64
	search *string
	from *string
	to *string
}

// Sub-Account API Key
func (r ApiGetSuppressionsRequest) XSubAccountApiKey(xSubAccountApiKey string) ApiGetSuppressionsRequest {
	r.xSubAccountApiKey = &xSubAccountApiKey
	return r
}

// offset
func (r ApiGetSuppressionsRequest) Offset(offset int64) ApiGetSuppressionsRequest {
	r.offset = &offset
	return r
}

// limit
func (r ApiGetSuppressionsRequest) Limit(limit int64) ApiGetSuppressionsRequest {
	r.limit = &limit
	return r
}

// search
func (r ApiGetSuppressionsRequest) Search(search string) ApiGetSuppressionsRequest {
	r.search = &search
	return r
}

// from date
func (r ApiGetSuppressionsRequest) From(from string) ApiGetSuppressionsRequest {
	r.from = &from
	return r
}

// to date
func (r ApiGetSuppressionsRequest) To(to string) ApiGetSuppressionsRequest {
	r.to = &to
	return r
}

func (r ApiGetSuppressionsRequest) Execute() ([]Suppression, *http.Response, error) {
	return r.ApiService.GetSuppressionsExecute(r)
}

/*
GetSuppressions Method for GetSuppressions

Get all suppressions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSuppressionsRequest
*/
func (a *SuppressionAPIService) GetSuppressions(ctx context.Context) ApiGetSuppressionsRequest {
	return ApiGetSuppressionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Suppression
func (a *SuppressionAPIService) GetSuppressionsExecute(r ApiGetSuppressionsRequest) ([]Suppression, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Suppression
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SuppressionAPIService.GetSuppressions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subaccount/suppression/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xSubAccountApiKey == nil {
		return localVarReturnValue, nil, reportError("xSubAccountApiKey is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-SubAccount-ApiKey", r.xSubAccountApiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
